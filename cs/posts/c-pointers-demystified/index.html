<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>C Pointers Demystified | @profnandaa | CS Blog</title>
<meta name="keywords" content="c, pointers">
<meta name="description" content="Introduction Pointers are variables that store the address of another variable.
Allow us to indirectly access variables (i.e. we can talk about its address rather than its value) Importance of Pointers: More flexible pass-by-reference Manipulate complex data structures efficiently, even if their data is scattered in deferent memory locations Use polymorphism - calling functions on data without knowing exactly what kind of data it is. (needs example!) Declaring Pointers Simply &lt;type&gt; *&lt;var_name&gt;;, e.">
<meta name="author" content="Anthony Nandaa">
<link rel="canonical" href="https://nandaa.dev/cs/posts/c-pointers-demystified/">
<link crossorigin="anonymous" href="/cs/assets/css/stylesheet.96899f97d8f8189d0ff2f895ef7d104ef2a38fa0104562f554c249c6476eda64.css" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/cs/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js"
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://nandaa.dev/cs/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://nandaa.dev/cs/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://nandaa.dev/cs/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://nandaa.dev/cs/apple-touch-icon.png">
<link rel="mask-icon" href="https://nandaa.dev/cs/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="C Pointers Demystified" />
<meta property="og:description" content="Introduction Pointers are variables that store the address of another variable.
Allow us to indirectly access variables (i.e. we can talk about its address rather than its value) Importance of Pointers: More flexible pass-by-reference Manipulate complex data structures efficiently, even if their data is scattered in deferent memory locations Use polymorphism - calling functions on data without knowing exactly what kind of data it is. (needs example!) Declaring Pointers Simply &lt;type&gt; *&lt;var_name&gt;;, e." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://nandaa.dev/cs/posts/c-pointers-demystified/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-17T03:01:44+03:00" />
<meta property="article:modified_time" content="2023-01-17T03:01:44+03:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="C Pointers Demystified"/>
<meta name="twitter:description" content="Introduction Pointers are variables that store the address of another variable.
Allow us to indirectly access variables (i.e. we can talk about its address rather than its value) Importance of Pointers: More flexible pass-by-reference Manipulate complex data structures efficiently, even if their data is scattered in deferent memory locations Use polymorphism - calling functions on data without knowing exactly what kind of data it is. (needs example!) Declaring Pointers Simply &lt;type&gt; *&lt;var_name&gt;;, e."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://nandaa.dev/cs/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "C Pointers Demystified",
      "item": "https://nandaa.dev/cs/posts/c-pointers-demystified/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "C Pointers Demystified",
  "name": "C Pointers Demystified",
  "description": "Introduction Pointers are variables that store the address of another variable.\nAllow us to indirectly access variables (i.e. we can talk about its address rather than its value) Importance of Pointers: More flexible pass-by-reference Manipulate complex data structures efficiently, even if their data is scattered in deferent memory locations Use polymorphism - calling functions on data without knowing exactly what kind of data it is. (needs example!) Declaring Pointers Simply \u0026lt;type\u0026gt; *\u0026lt;var_name\u0026gt;;, e.",
  "keywords": [
    "c", "pointers"
  ],
  "articleBody": "Introduction Pointers are variables that store the address of another variable.\nAllow us to indirectly access variables (i.e. we can talk about its address rather than its value) Importance of Pointers: More flexible pass-by-reference Manipulate complex data structures efficiently, even if their data is scattered in deferent memory locations Use polymorphism - calling functions on data without knowing exactly what kind of data it is. (needs example!) Declaring Pointers Simply *;, e.g.\nint *ptr; The pointer can then be initialized to a memory address for a variable, which is found by using \u0026, e.g.\nint x = 20; int *px = \u0026x; To illustrate this with a diagram and code, consider the following simple program:\n// pointers1.c #include int main() { int x = 20; int *px = \u0026x; printf(\"ptr: %p -\u003e addr %p has: %d\\n\", \u0026px, px, x); return 0; } When compiled with gcc pointers1.c and run, you get something similar to this:\nptr: 0x7ffec8780c10 -\u003e addr 0x7ffec8780c0c has: 20 the pointer px is in address 0x7ffec8780c10, pointing 4 bytes away at address 0x7ffec8780c0c that contains x; consider the diagram below\nℹ Note My own preference and the prevalent practice is to put the * just before the name of the variable as opposed to putting it after the type, as some do. The later is also misleading when you have a list of variables in one line, e.g. int *ptr, x, y vs. int* ptr, x, y. (x and y are just integers but the later may make it look like all are pointers!)\nDereferencing Pointers To dereference a pointer is to get the value of what the pointer is pointing to. We use *, for example: int x = 30; int *px = \u0026x; *px = 40; // changes x // print memory address of where px is pointing // at (px) and the value in the address (*px) printf(\"%p -\u003e %d\\n\", px, *px); // also note that the pointer also is stored // somewhere in memory and we can get its location // by \u0026px, e.g. printf(\"%p\\n\", \u0026px); // so printf(\"%p stores -\u003e %p (px), which stores -\u003e %d (x)\\n\", \u0026px, px, *px); Null Pointers Any pointer set to 0 is called a null pointer, since there’s no memory location 0, it is an invalid pointer.\nDereferencing such a pointer leads to a runtime error. One should check whether the pointer is null before dereferencing it.\nint *py = 0; // or int *py = NULL; printf(\"%d\\n\", *py); // seg-fault! You may ask, what’s the point for null pointers? Null pointers are very important for initializing pointers which will point to proper memory addresses later on, but they are not yet determined. If we declared int *pz; without initializing it, the compiler (GCC in my case), will point pz to a random memory address (“allocate”). However, this is not guaranteed, will seg-fault too, sometimes.\nint *pz; printf(\"%d\\n\", *pz); Pointers and Arrays An array is a list of values arranged sequentially in memory.\nThe variable name of the array is usually a special kind of pointer, it can decay into a pointer; as we will see below:\nint arr[] = { 1, 2, 3 }; // `arr` decays into int* (int pointer) Therefore, arr in the example above is equivalent to an int*. arr is a pointer pointing to the beginning of the array.\nTo get the first element of the array, we will use *arr.\nTo get the second element of the array, we use *(arr + 1)\nTherefore to get the nth element of the array we will use *(arr + n - 1).\nint arr[] = { 1, 2, 3 }; printf(\"%d, %d, %d\\n\", *arr, *(arr + 1), *(arr + 2)); Let’s look at an example for summing up numbers in an array:\nint sumArray(int *arr, int sz) { int sum = 0; for (int i = 0; i \u003c sz; ++i) { sum += *(arr + i); // or sum += arr[i] } return sum; } sumArray takes in a pointer to an array and the size of that array. However, there’s not way of telling (AFAIK) that that pointer truly points to an array, it could as well just be an ordinary pointer to an int. For instance of if we gave x (from our example in the beginning) to this function, it will compile correctly and it may even run without a seg-fault! printf(\"fake sum -\u003e %d\\n\", sumArray(px, 3)); // if you thought that's enough, try this! printf(\"fake sum -\u003e %d\\n\", sumArray(px, 300)); // 300 contiguous memory addresses // from px are summed up This is the same reason why strings (array of chars) have a sentinel value \\0 at the end that signifies the end of the array (aka, the null terminator). ℹ Note In the next section, we will look at pointer-to-pointer. It is worth noting here that \u0026arr in our example above will be an int** (pointer to pointer, or address of a pointer arr), since arr is int*.\nIncrementing Pointers Since pointers point to memory addresses which are contiguous, it is therefore possible to increment a pointer to move to the next address. The pointer will step according to it’s size, e.g. int * will be stepping 32 bits (4 bytes) each.\nLet’s look at an example:\nint arr[] = { 1, 2, 3, 4 }; int *p = arr; // points to the first element in arr p++; // now p is pointing at the 2nd element printf(\"p -\u003e %d\\n\", *p); printf(\"p -\u003e %d\\n\", *(++p)); // pointer now pointing to the 3rd This should be done strictly for guaranteed contiguous memory addresses, i.e. arrays, and you should know where the end is (where to stop).\nCharacter Pointers In C, we create a string by using an array of characters (loosely). A pointer pointing to this array is therefore a character pointer.\nIt will be insane to just have one pointer pointing to one char, what’s the point?\nNow, how do we tell we have reached the end of our “string”? We use a null terminator \\0. That is when it is a proper string, else, it’s just an array of characters.\nLet’s look at an example:\nchar s[] = { 'h', 'e', 'l', 'l', 'o', '\\0' }; char *ps = s; // notice that the length of the array will always be +1 the length of the // string, because of the \\0 printf(\"%s, str length = %ld, array length = %d\\n\", ps, strlen(ps), sizeof(sl)); // a shorter way to initalize this: char *ps2 = \"another hello\"; // using double quotes to denote string printf(\"%s, length = %ld\\n\", ps2, strlen(ps2)); As we had mentioned earlier, there is no way to know you have reached the end of an array, unless you put a sentinel value to mark the end. We use \\0 to mark the end of a string. For instance, this:\nchar hackedStr[] = { 'g', 'o', '\\0', 'o', 'd'}; printf(\"%s, str length = %ld, array length = %ld\\n\", hackedStr, strlen(hackedStr), sizeof(hackedStr)); Pointer to Pointer We can have a pointer pointing to a pointer, and even another pointer pointing to the/that pointer (pointer -\u003e pointer -\u003e pointer).\nLet’s look at a simple example:\nint y = 10; int *py = \u0026y; int **ppy = \u0026py; int ***pppy = \u0026ppy; // we can go on and on printf(\"%p -\u003e %p -\u003e %p -\u003e %d\\n\", pppy, ppy, py, y); // we can deference any to get to our int value // notice the symetry in the * // as per the declaration printf(\"%d, %d, %d\\n\", ***pppy, **ppy, *py); // likewise you can modify through indirection ***pppy = 40; printf(\"%d\\n\", y); Likewise, you can have a pointer that points to the array pointer, eg:\nint arr2[] = { 2, 5, 6, 8 }; int *p2 = arr2; int **ppArr = \u0026p2; printf(\"1st element in arr: %d\\n\", **ppArr); printf(\"2nd element in arr: %d\\n\", *(*ppArr + 1)); // notice the brackets We will see why this is important when we look at the the next section on passing by value and by reference.\nPointers and Functions Passing by Value vs. by Reference A pointer is a value too, only that that value is a reference. Let that sink in.\nTherefore you can pass a pointer to a function by value or by reference. Reference here will be a pointer to that pointer.\nTo illustrate this, let’s look at the following example:\nvoid swap1(int *a, int *b) { int *temp = a; a = b; b = temp; } // the above function is for illustration purpose only // the actual swapping function should be: /* void swap(int *a, int *b) { int temp = *a; *a = *b; *b = temp; } */ int m = 30, n = 20; int *pm = \u0026m, *pn = \u0026n; swap1(pm, pn); // passed by value printf(\"m -\u003e %d, n -\u003e %d\\n\", *pm, *pn); // no swap done! Basically, we just passed by value (a copy of the pointers) to the function, and therefore, our original pointers remained untouched.\nWe have to pass by refeference (a pointer to the pointer):\nvoid swap2(int **a, int **b) { int *temp = *a; *a = *b; *b = temp; } int m = 30, n = 20; int *pm = \u0026m, *pn = \u0026n; swap2(\u0026pm, \u0026pn); printf(\"m -\u003e %d, n -\u003e %d\\n\", *pm, *pn); // now swap done Returning Pointers As you may have known by now, you can pass pointers to functions and also you can return pointers from a function.\nThe following example is very buggy but it passes the point across – that you can return a pointer from a function. I leave the exercise of finding out why it’s buggy to you, to save on the space that I’d have to use to explain how the function callstack works:\nWe will revisit this example when we look at malloc.\nint* return_ptr() { int x = 30; return \u0026x; // pointer to x (local) } Pointer to Functions I’d initially planned to cover this topic as a sub-section of Pointers and Functions but I think it deserves it’s own section.\nThis concept is not covered in most books but it is such a powerful concept. With pointers to functions, you can now pass functions to other functions (by reference).\nThis is the general format on how you declare such a pointer:\n(*)() = \u0026 For example, for a function with a signature like int sum(int x, int y), this is how we will write its pointer:\nint sum(int x, int y); int (*sum_ptr)(int, int) = \u0026sum; // and then calling int z = (*sum_ptr)(30, 50); And thefore you can pass it to another function thus:\nvoid do_op(int (*fn_ptr)(int, int)) { int x = 30, y = 40; printf(\"%d + %d = %d\\n\", x, y, (*fn_ptr)(x, y)); } int main() { // ... do_op(\u0026sum); // ... return 0; } Let’s look at another example of a callback function print(int) passed to another function mul which multiplies two numbers and then calls the print function which prints out the results. So we leave the caller decide on how they want to print, formatting, etc.\n#include void print(int prod) { printf(\"The product = %d\\n\", prod); } void mul(int x, int y, void (*print_fn)(int)) { int prod = x * y; (*print_fn)(prod); } int main() { mul(20, 30, \u0026print); return 0; } malloc, calloc and free TBD - I would to do a good service ot this sub-topic, especially explain the difference between the heap and the stack and the interelation. So, check out the next update coming soon.\nMemory Leaks A Leak occurs when a process fails to release a resource in a timely manner. Memory leak occurs when programmers create a memory in heap and forget to delete it. Examples: TBD\nPointers War Stories TBD – if you have any war stories, please do share - pointers@nandaa.dev.\nFurther Reading I’d encourage you to take a look at a number of opensource C source-codes and see how pointers are used. For a start, you can check out the following:\nLinux source-code Git source-code 💡 This series is a WIP, keep checking back for updates. Will try do a changelog This blog can be reviewed inline here, I will appreciate your suggestions, comments and nitpicks.\n",
  "wordCount" : "2053",
  "inLanguage": "en",
  "datePublished": "2023-01-17T03:01:44+03:00",
  "dateModified": "2023-01-17T03:01:44+03:00",
  "author":{
    "@type": "Person",
    "name": "Anthony Nandaa"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://nandaa.dev/cs/posts/c-pointers-demystified/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "@profnandaa | CS Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://nandaa.dev/cs/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://nandaa.dev/cs/" accesskey="h" title="@profnandaa | CS Blog (Alt + H)">@profnandaa | CS Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      C Pointers Demystified
    </h1>
    <div class="post-meta"><span title='2023-01-17 03:01:44 +0300 EAT'>January 17, 2023</span>&nbsp;·&nbsp;Anthony Nandaa

</div>
  </header> 
  <div class="post-content"><h2 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h2>
<p><strong>Pointers</strong> are variables that store the address of another variable.</p>
<ul>
<li>Allow us to <em>indirectly</em> access variables (i.e. we can talk about its address rather than its <em>value</em>)</li>
</ul>
<h3 id="importance-of-pointers">Importance of Pointers:<a hidden class="anchor" aria-hidden="true" href="#importance-of-pointers">#</a></h3>
<ul>
<li>More flexible pass-by-reference</li>
<li>Manipulate complex data structures efficiently, even if their data is scattered in deferent memory locations</li>
<li>Use polymorphism - calling functions on data without knowing exactly what kind of data it is. (<em>needs example!</em>)</li>
</ul>
<h2 id="declaring-pointers">Declaring Pointers<a hidden class="anchor" aria-hidden="true" href="#declaring-pointers">#</a></h2>
<p>Simply <code>&lt;type&gt; *&lt;var_name&gt;;</code>, e.g.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>ptr;
</span></span></code></pre></div><p>The pointer can then be initialized to a memory address for a variable, which is found by using <code>&amp;</code>, e.g.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>px <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>x;
</span></span></code></pre></div><p>To illustrate this with a diagram and code, consider the following  simple program:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// pointers1.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>px <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>x;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;ptr: %p -&gt; addr %p has: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>px, px, x);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>When compiled with <code>gcc pointers1.c</code> and run, you get something similar to this:</p>
<pre tabindex="0"><code>ptr: 0x7ffec8780c10 -&gt; addr 0x7ffec8780c0c has: 20
</code></pre><p><em>the pointer <code>px</code> is in address <code>0x7ffec8780c10</code>, pointing 4 bytes away at address <code>0x7ffec8780c0c</code> that contains <code>x</code>; consider the diagram below</em></p>
<p><img loading="lazy" src="https://user-images.githubusercontent.com/261265/213256470-873f6f21-a967-4b49-9858-9608ada9d525.png" alt="memory_model"  />
</p>
<blockquote>
<p>ℹ <strong>Note</strong> <!-- raw HTML omitted -->
My own preference and the prevalent practice is to put the <code>*</code> just before the name of the variable as opposed to putting it after the type, as some do. The later is also misleading when you have a list of variables in one line, e.g. <!-- raw HTML omitted --><code>int *ptr, x, y</code> vs. <code>int* ptr, x, y</code>. <!-- raw HTML omitted -->(<code>x</code> and <code>y</code> are just integers but the later may make it look like all are pointers!)</p>
</blockquote>
<h2 id="dereferencing-pointers">Dereferencing Pointers<a hidden class="anchor" aria-hidden="true" href="#dereferencing-pointers">#</a></h2>
<ul>
<li>To dereference a pointer is to get the value of what the pointer is pointing to.</li>
<li>We use <code>*&lt;pointer_pointer_var_name&gt;</code>, for example:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">30</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>px <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>x;
</span></span><span style="display:flex;"><span><span style="color:#f92672">*</span>px <span style="color:#f92672">=</span> <span style="color:#ae81ff">40</span>; <span style="color:#75715e">// changes x
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// print memory address of where px is pointing 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// at (px) and the value in the address (*px)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%p -&gt; %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, px, <span style="color:#f92672">*</span>px); 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// also note that the pointer also is stored 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// somewhere in memory and we can get its location 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// by &amp;px, e.g.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>px);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// so
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%p stores -&gt; %p (px), which stores -&gt; %d (x)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>px, px, <span style="color:#f92672">*</span>px);
</span></span></code></pre></div></li>
</ul>
<h2 id="null-pointers">Null Pointers<a hidden class="anchor" aria-hidden="true" href="#null-pointers">#</a></h2>
<ul>
<li>
<p>Any pointer set to <code>0</code> is called a <em>null pointer</em>, since there&rsquo;s no memory location <code>0</code>, it is an invalid pointer.</p>
</li>
<li>
<p>Dereferencing such a pointer leads to a runtime error. One should check whether the pointer is null before dereferencing it.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>py <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// or int *py = NULL;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">*</span>py); <span style="color:#75715e">// seg-fault!
</span></span></span></code></pre></div></li>
<li>
<p>You may ask, what&rsquo;s the point for <em>null pointers</em>? Null pointers are very important for initializing pointers which will point to proper memory addresses later on, but they are not yet determined. If we declared <code>int *pz;</code> without initializing it, the compiler (GCC in my case), will point <code>pz</code> to a random memory address (&ldquo;allocate&rdquo;). However, this is not guaranteed, will <em>seg-fault</em> too, sometimes.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>pz;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">*</span>pz);
</span></span></code></pre></div></li>
</ul>
<h2 id="pointers-and-arrays">Pointers and Arrays<a hidden class="anchor" aria-hidden="true" href="#pointers-and-arrays">#</a></h2>
<ul>
<li>
<p>An array is a list of values arranged sequentially in memory.</p>
</li>
<li>
<p>The variable name of the array is usually <em>a special kind of pointer</em>, it can decay into a pointer; as we will see below:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> arr[] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span> }; <span style="color:#75715e">// `arr` decays into int* (int pointer)
</span></span></span></code></pre></div></li>
<li>
<p>Therefore, <code>arr</code> in the example above is equivalent to an <code>int*</code>. <code>arr</code> is a pointer pointing to the beginning of the array.</p>
</li>
<li>
<p>To get the first element of the array, we will use <code>*arr</code>.</p>
</li>
<li>
<p>To get the second element of the array, we use <code>*(arr + 1)</code></p>
</li>
<li>
<p>Therefore to get the <em>nth</em> element of the array we will use <code>*(arr + n - 1)</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> arr[] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span> };
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d, %d, %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">*</span>arr, <span style="color:#f92672">*</span>(arr <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>), <span style="color:#f92672">*</span>(arr <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>));
</span></span></code></pre></div></li>
<li>
<p>Let&rsquo;s look at an example for summing up numbers in an array:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">sumArray</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>arr, <span style="color:#66d9ef">int</span> sz)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> sz; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        sum <span style="color:#f92672">+=</span> <span style="color:#f92672">*</span>(arr <span style="color:#f92672">+</span> i); <span style="color:#75715e">// or sum += arr[i]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> sum;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><code>sumArray</code> takes in a pointer to an array and the size of that array.</li>
<li>However, there&rsquo;s not way of telling (AFAIK) that that pointer truly points to an array, it could as well just be an ordinary pointer to an int. For instance of if we gave <code>x</code> (from our example in the beginning) to this function, it will compile correctly and it may even run without a seg-fault!
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;fake sum -&gt; %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">sumArray</span>(px, <span style="color:#ae81ff">3</span>));
</span></span><span style="display:flex;"><span><span style="color:#75715e">// if you thought that&#39;s enough, try this!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;fake sum -&gt; %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">sumArray</span>(px, <span style="color:#ae81ff">300</span>));
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 300 contiguous memory addresses
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// from px are summed up
</span></span></span></code></pre></div></li>
<li>This is the same reason why strings (array of chars) have a sentinel value <code>\0</code> at the end that signifies the end of the array (aka, <em>the null terminator</em>).</li>
</ul>
<blockquote>
<p><strong>ℹ Note</strong> <!-- raw HTML omitted -->
In the next section, we will look at pointer-to-pointer. It is worth noting here that <code>&amp;arr</code> in our example above will be an <code>int**</code> (pointer to pointer, or address of a pointer <code>arr</code>), since <code>arr</code> is <code>int*</code>.</p>
</blockquote>
</li>
</ul>
<h3 id="incrementing-pointers">Incrementing Pointers<a hidden class="anchor" aria-hidden="true" href="#incrementing-pointers">#</a></h3>
<p>Since pointers point to memory addresses which are contiguous, it is therefore possible to increment a pointer to move to the next address. The pointer will step according to it&rsquo;s size, e.g. <code>int *</code> will be stepping 32 bits (4 bytes) each.</p>
<p>Let&rsquo;s look at an example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> arr[] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span> };
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> arr;   <span style="color:#75715e">// points to the first element in arr
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>p<span style="color:#f92672">++</span>;            <span style="color:#75715e">// now p is pointing at the 2nd element
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;p -&gt; %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">*</span>p);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;p -&gt; %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">*</span>(<span style="color:#f92672">++</span>p)); <span style="color:#75715e">// pointer now pointing to the 3rd
</span></span></span></code></pre></div><p>This should be done strictly for <em>guaranteed</em> contiguous memory addresses, i.e. arrays, and you should know where the end is (where to stop).</p>
<h3 id="character-pointers">Character Pointers<a hidden class="anchor" aria-hidden="true" href="#character-pointers">#</a></h3>
<p>In C, we create a <em>string</em> by using an array of characters (loosely). A pointer pointing to this array is therefore a character pointer.</p>
<blockquote>
<p><em>It will be insane to just have one pointer pointing to one char, what&rsquo;s the point?</em></p>
</blockquote>
<p>Now, how do we tell we have reached the end of our &ldquo;string&rdquo;? We use a null terminator <code>\0</code>. That is when it is a proper string, else, it&rsquo;s just an array of characters.</p>
<p>Let&rsquo;s look at an example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">char</span> s[] <span style="color:#f92672">=</span> { <span style="color:#e6db74">&#39;h&#39;</span>, <span style="color:#e6db74">&#39;e&#39;</span>, <span style="color:#e6db74">&#39;l&#39;</span>, <span style="color:#e6db74">&#39;l&#39;</span>, <span style="color:#e6db74">&#39;o&#39;</span>, <span style="color:#e6db74">&#39;\0&#39;</span> };
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>ps <span style="color:#f92672">=</span> s;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// notice that the length of the array will always be +1 the length of the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// string, because of the \0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%s, str length = %ld, array length = %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ps, <span style="color:#a6e22e">strlen</span>(ps), <span style="color:#66d9ef">sizeof</span>(sl));
</span></span><span style="display:flex;"><span><span style="color:#75715e">// a shorter way to initalize this:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>ps2 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;another hello&#34;</span>; <span style="color:#75715e">// using double quotes to denote string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%s, length = %ld</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ps2, <span style="color:#a6e22e">strlen</span>(ps2));
</span></span></code></pre></div><p>As we had mentioned earlier, there is no way to know you have reached the end of an array, unless you put a <em>sentinel</em> value to mark the end. We use <code>\0</code> to mark the end of a string. For instance, this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">char</span> hackedStr[] <span style="color:#f92672">=</span> { <span style="color:#e6db74">&#39;g&#39;</span>, <span style="color:#e6db74">&#39;o&#39;</span>, <span style="color:#e6db74">&#39;\0&#39;</span>, <span style="color:#e6db74">&#39;o&#39;</span>, <span style="color:#e6db74">&#39;d&#39;</span>};
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%s, str length = %ld, array length = %ld</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, hackedStr, <span style="color:#a6e22e">strlen</span>(hackedStr), <span style="color:#66d9ef">sizeof</span>(hackedStr));
</span></span></code></pre></div><h2 id="pointer-to-pointer">Pointer to Pointer<a hidden class="anchor" aria-hidden="true" href="#pointer-to-pointer">#</a></h2>
<p>We can have a pointer pointing to a pointer, and even another pointer pointing to the/that pointer (<code>pointer -&gt; pointer -&gt; pointer</code>).</p>
<p>Let&rsquo;s look at a simple example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>py <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>y;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">**</span>ppy <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>py;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">***</span>pppy <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>ppy; <span style="color:#75715e">// we can go on and on
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%p -&gt; %p -&gt; %p -&gt; %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, pppy, ppy, py, y);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// we can deference any to get to our int value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// notice the symetry in the *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// as per the declaration
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d, %d, %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">***</span>pppy, <span style="color:#f92672">**</span>ppy, <span style="color:#f92672">*</span>py);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// likewise you can modify through indirection
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">***</span>pppy <span style="color:#f92672">=</span> <span style="color:#ae81ff">40</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, y);
</span></span></code></pre></div><p>Likewise, you can have a pointer that points to the array pointer, eg:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> arr2[] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">8</span> };
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p2 <span style="color:#f92672">=</span> arr2;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">**</span>ppArr <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>p2;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;1st element in arr: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">**</span>ppArr);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;2nd element in arr: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>ppArr <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)); <span style="color:#75715e">// notice the brackets
</span></span></span></code></pre></div><blockquote>
<p><em>We will see why this is important when we look at the the next section on passing by value and by reference.</em></p>
</blockquote>
<h2 id="pointers-and-functions">Pointers and Functions<a hidden class="anchor" aria-hidden="true" href="#pointers-and-functions">#</a></h2>
<h3 id="passing-by-value-vs-by-reference">Passing by Value vs. by Reference<a hidden class="anchor" aria-hidden="true" href="#passing-by-value-vs-by-reference">#</a></h3>
<p>A pointer is a <em>value</em> too, only that that value is a reference. <em>Let that sink in</em>.</p>
<p>Therefore you can pass a pointer to a function <em>by value</em> or <em>by reference</em>. Reference here will be a pointer to that pointer.</p>
<p>To illustrate this, let&rsquo;s look at the following example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">swap1</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>a, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>temp <span style="color:#f92672">=</span> a;
</span></span><span style="display:flex;"><span>    a <span style="color:#f92672">=</span> b;
</span></span><span style="display:flex;"><span>    b <span style="color:#f92672">=</span> temp;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// the above function is for illustration purpose only
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// the actual swapping function should be:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">void swap(int *a, int *b)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">{
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    int temp = *a;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    *a = *b;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    *b = temp;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> <span style="color:#ae81ff">30</span>, n <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>pm <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>m, <span style="color:#f92672">*</span>pn <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>n;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">swap1</span>(pm, pn); <span style="color:#75715e">// passed by value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;m -&gt; %d, n -&gt; %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">*</span>pm, <span style="color:#f92672">*</span>pn); <span style="color:#75715e">// no swap done!
</span></span></span></code></pre></div><p>Basically, we just passed by value (a copy of the pointers) to the function, and therefore, our original pointers remained untouched.</p>
<p>We have to pass by refeference (a pointer to the pointer):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">swap2</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">**</span>a, <span style="color:#66d9ef">int</span> <span style="color:#f92672">**</span>b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>temp <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>a;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>a <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>b;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>b <span style="color:#f92672">=</span> temp;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> <span style="color:#ae81ff">30</span>, n <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>pm <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>m, <span style="color:#f92672">*</span>pn <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>n;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">swap2</span>(<span style="color:#f92672">&amp;</span>pm, <span style="color:#f92672">&amp;</span>pn);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;m -&gt; %d, n -&gt; %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">*</span>pm, <span style="color:#f92672">*</span>pn); <span style="color:#75715e">// now swap done
</span></span></span></code></pre></div><h3 id="returning-pointers">Returning Pointers<a hidden class="anchor" aria-hidden="true" href="#returning-pointers">#</a></h3>
<p>As you may have known by now, you can pass pointers to functions and also you can return pointers from a function.</p>
<p>The following example is <strong>very buggy</strong> but it passes the point across &ndash; that you can return a pointer from a function. I leave the exercise of finding out why it&rsquo;s buggy to you, to save on the space that I&rsquo;d have to use to explain how the <em>function callstack</em> works:</p>
<blockquote>
<p><em>We will revisit this example when we look at <code>malloc</code>.</em></p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">return_ptr</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">30</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span>x; <span style="color:#75715e">// pointer to x (local)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="pointer-to-functions">Pointer to Functions<a hidden class="anchor" aria-hidden="true" href="#pointer-to-functions">#</a></h2>
<blockquote>
<p><em>I&rsquo;d initially planned to cover this topic as a sub-section of <strong>Pointers and Functions</strong> but I think it deserves it&rsquo;s own section.</em></p>
</blockquote>
<p>This concept is not covered in most books but it is such a powerful concept. With pointers to functions, you can now pass functions to other functions (by reference).</p>
<p>This is the general format on how you declare such a pointer:</p>
<pre tabindex="0"><code>&lt;return_type&gt; (*&lt;name_of_ptr&gt;)(&lt;type_of_params,...&gt;) = &amp;&lt;the_function_pointed_to&gt;
</code></pre><p>For example, for a function with a signature like <code>int sum(int x, int y)</code>, this is how we will write its pointer:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">sum</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>sum_ptr)(<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>) <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>sum;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// and then calling
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> z <span style="color:#f92672">=</span> (<span style="color:#f92672">*</span>sum_ptr)(<span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">50</span>);
</span></span></code></pre></div><p>And thefore you can pass it to another function thus:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">do_op</span>(<span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>fn_ptr)(<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>)) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">30</span>, y <span style="color:#f92672">=</span> <span style="color:#ae81ff">40</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d + %d = %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, x, y, (<span style="color:#f92672">*</span>fn_ptr)(x, y));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">do_op</span>(<span style="color:#f92672">&amp;</span>sum);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Let&rsquo;s look at another example of a <em>callback</em> function <code>print(int)</code> passed to another function <code>mul</code> which multiplies two numbers and then calls the <code>print</code> function which prints out the results. So we leave the caller decide on how they want to print, formatting, etc.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span>(<span style="color:#66d9ef">int</span> prod) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;The product = %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, prod);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mul</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y, <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>print_fn)(<span style="color:#66d9ef">int</span>)) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> prod <span style="color:#f92672">=</span> x <span style="color:#f92672">*</span> y;
</span></span><span style="display:flex;"><span>    (<span style="color:#f92672">*</span>print_fn)(prod);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mul</span>(<span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">30</span>, <span style="color:#f92672">&amp;</span>print);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="malloc-calloc-and-free"><code>malloc</code>, <code>calloc</code> and <code>free</code><a hidden class="anchor" aria-hidden="true" href="#malloc-calloc-and-free">#</a></h2>
<blockquote>
<p><em><strong>TBD</strong> - I would to do a good service ot this sub-topic, especially explain the difference between the heap and the stack and the interelation. So, check out the next update coming soon.</em></p>
</blockquote>
<h2 id="memory-leaks">Memory Leaks<a hidden class="anchor" aria-hidden="true" href="#memory-leaks">#</a></h2>
<ul>
<li>A <em>Leak</em> occurs when a process fails to release a resource in a timely manner.</li>
<li>Memory leak occurs when programmers create a memory in heap and forget to delete it.</li>
</ul>
<blockquote>
<p>Examples: TBD</p>
</blockquote>
<h2 id="pointers-war-stories">Pointers War Stories<a hidden class="anchor" aria-hidden="true" href="#pointers-war-stories">#</a></h2>
<blockquote>
<p><em><strong>TBD</strong> &ndash; if you have any war stories, please do share - <code>pointers@nandaa.dev</code>.</em></p>
</blockquote>
<h2 id="further-reading">Further Reading<a hidden class="anchor" aria-hidden="true" href="#further-reading">#</a></h2>
<p>I&rsquo;d encourage you to take a look at a number of opensource C source-codes and see how pointers are used. For a start, you can check out the following:</p>
<ul>
<li><a href="https://elixir.bootlin.com/linux/latest/source">Linux source-code</a></li>
<li><a href="https://github.com/git/git">Git source-code</a></li>
</ul>
<blockquote>
<p>💡 <em>This series is a WIP, keep checking back for updates. Will try do a changelog</em>
<em>This blog can be <a href="https://github.com/profnandaa/profnandaa.github.io/pull/2">reviewed inline here</a>, I will appreciate your suggestions, comments and nitpicks.</em></p>
</blockquote>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://nandaa.dev/cs/tags/c/">c</a></li>
      <li><a href="https://nandaa.dev/cs/tags/pointers/">pointers</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://nandaa.dev/cs/">@profnandaa | CS Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
